<!DOCTYPE html>
<html>
<head>
    <title>AR –ó–≤–µ—Ä–∏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
        }
        #arButton {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="status">‚è≥ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
    <button id="arButton" style="display: none;">üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å AR</button>

    <script>
        class ARGame {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.statusElement = document.getElementById('status');
                this.arButton = document.getElementById('arButton');
                this.engine = null;
                this.scene = null;
                this.xr = null;
                this.init();
            }

            async init() {
                try {
                    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ WebGL
                    if (!this.checkWebGLSupport()) return;

                    // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–∫–∞
                    this.engine = new BABYLON.Engine(this.canvas, true);
                    this.updateStatus("üéÆ –î–≤–∏–∂–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");

                    // 3. –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–π —Å—Ü–µ–Ω—ã
                    this.scene = await this.createBasicScene();
                    
                    // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ AR
                    if (await this.checkARSupport()) {
                        this.setupARButton();
                    } else {
                        this.createFallbackScene();
                    }

                    // 5. –ó–∞–ø—É—Å–∫ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
                    this.engine.runRenderLoop(() => {
                        this.scene.render();
                    });

                } catch (error) {
                    this.showError(`üí• –û—à–∏–±–∫–∞: ${error.message}`);
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ WebGL –ø–æ–¥–¥–µ—Ä–∂–∫–∏
            checkWebGLSupport() {
                if (!BABYLON.Engine.isSupported()) {
                    this.showError("‚ùå WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º");
                    return false;
                }
                return true;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–π 3D —Å—Ü–µ–Ω—ã
            async createBasicScene() {
                const scene = new BABYLON.Scene(this.engine);
                
                // –ö–∞–º–µ—Ä–∞
                const camera = new BABYLON.ArcRotateCamera(
                    "camera", 
                    -Math.PI/2, 
                    Math.PI/2.5, 
                    15, 
                    BABYLON.Vector3.Zero(), 
                    scene
                );
                camera.attachControl(this.canvas, false);

                // –û—Å–≤–µ—â–µ–Ω–∏–µ
                new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
                
                // –ó–µ–º–ª—è
                const ground = BABYLON.MeshBuilder.CreateGround(
                    "ground", 
                    { width: 20, height: 20 }, 
                    scene
                );
                ground.position.y = -1;

                // –°–ø–∞–≤–Ω –∑–≤–µ—Ä–µ–π
                this.spawnRandomAnimals(scene, 10);

                this.updateStatus("ü¶Å –ë–∞–∑–æ–≤–∞—è —Å—Ü–µ–Ω–∞ –≥–æ—Ç–æ–≤–∞");
                return scene;
            }

            // –°–ø–∞–≤–Ω —Å–ª—É—á–∞–π–Ω—ã—Ö –∂–∏–≤–æ—Ç–Ω—ã—Ö
            spawnRandomAnimals(scene, count) {
                const animalColors = [
                    new BABYLON.Color3(1, 0.2, 0.2), // –ö—Ä–∞—Å–Ω—ã–π
                    new BABYLON.Color3(0.2, 1, 0.2), // –ó–µ–ª–µ–Ω—ã–π
                    new BABYLON.Color3(0.2, 0.2, 1)  // –°–∏–Ω–∏–π
                ];

                for (let i = 0; i < count; i++) {
                    const animal = BABYLON.MeshBuilder.CreateSphere(
                        `animal_${i}`, 
                        { diameter: 0.8 }, 
                        scene
                    );
                    animal.position = new BABYLON.Vector3(
                        Math.random() * 16 - 8,
                        0.5,
                        Math.random() * 16 - 8
                    );
                    
                    const material = new BABYLON.StandardMaterial("mat", scene);
                    material.diffuseColor = animalColors[Math.floor(Math.random() * 3)];
                    animal.material = material;
                }
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ AR
            async checkARSupport() {
                if (!navigator.xr) return false;
                try {
                    return await navigator.xr.isSessionSupported('immersive-ar');
                } catch {
                    return false;
                }
            }

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–Ω–æ–ø–∫–∏ AR
            setupARButton() {
                this.arButton.style.display = "block";
                this.arButton.onclick = async () => {
                    try {
                        this.updateStatus("üîÑ –ó–∞–ø—É—Å–∫ AR...");
                        await this.enableAR();
                    } catch (error) {
                        this.showError(`üö´ AR –æ—à–∏–±–∫–∞: ${error.message}`);
                    }
                };
            }

            // –ê–∫—Ç–∏–≤–∞—Ü–∏—è AR —Ä–µ–∂–∏–º–∞
            async enableAR() {
                this.xr = await this.scene.createDefaultXRExperienceAsync({
                    uiOptions: {
                        sessionMode: "immersive-ar",
                        referenceSpaceType: "local-floor"
                    }
                });

                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏
                this.xr.baseExperience.sessionManager.onXRSessionEnded.add(() => {
                    this.updateStatus("üîÑ –í–æ–∑–≤—Ä–∞—Ç –≤ 3D —Ä–µ–∂–∏–º");
                    this.createFallbackScene();
                });

                this.updateStatus("üåü AR —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–µ–Ω! –°–º–æ—Ç—Ä–∏—Ç–µ –≤–æ–∫—Ä—É–≥!");
            }

            // –†–µ–∑–µ—Ä–≤–Ω–∞—è 3D —Å—Ü–µ–Ω–∞
            createFallbackScene() {
                this.scene.activeCamera.alpha += Math.PI;
                this.updateStatus("üéÆ 3D —Ä–µ–∂–∏–º - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–∞—Å–∞–Ω–∏–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è");
            }

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
            updateStatus(text) {
                this.statusElement.textContent = text;
                console.log(text);
            }

            // –ü–æ–∫–∞–∑ –æ—à–∏–±–æ–∫
            showError(message) {
                this.statusElement.style.color = "#ff4444";
                this.statusElement.textContent = message;
                console.error(message);
            }
        }

        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => new ARGame());

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            if (game?.engine) {
                game.engine.resize();
            }
        });
    </script>
</body>
</html>
