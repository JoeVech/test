<!DOCTYPE html>
<html>
<head>
    <title>AR Зверь</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        #videoContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            text-align: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <div class="loader" id="loader">Инициализация камеры...</div>
    <video id="videoContainer" autoplay playsinline muted></video>
    <div id="canvasContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        (function() {
            const loader = document.getElementById('loader');
            let scene, camera, renderer, beast, pulseRing;
            let isCameraReady = false;

            const config = {
                sprite: {
                    width: 96,
                    height: 24,
                    frameWidth: 24,
                    frameHeight: 24,
                    tilesHoriz: 4,
                    tilesVert: 1,
                    scale: 1.2,
                    frameDuration: 150,
                    positionZ: -2
                },
                rhythm: {
                    radius: 0.8,
                    pulseSpeed: 0.3,
                    beatInterval: 2000,
                    maxScale: 1.3
                },
                camera: {
                    fov: 45,
                    positionZ: 3,
                    near: 0.1,
                    far: 1000
                }
            };

            if (typeof Telegram !== 'undefined') {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
            }

            async function initCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });

                    const video = document.getElementById('videoContainer');
                    video.srcObject = stream;

                    video.addEventListener('playing', () => {
                        isCameraReady = true;
                        loader.style.opacity = '0';
                        setTimeout(() => {
                            loader.style.display = 'none';
                            initThreeJS();
                        }, 300);
                    });

                } catch (error) {
                    loader.innerHTML = `
                        <div style="color: red; padding: 15px; background: rgba(0,0,0,0.8); border-radius: 8px;">
                            <h3 style="margin:0;">Ошибка камеры!</h3>
                            <p>${error.message}</p>
                        </div>`;
                }
            }

            function initThreeJS() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(
                    config.camera.fov,
                    window.innerWidth / window.innerHeight,
                    config.camera.near,
                    config.camera.far
                );
                camera.position.set(0, 0, config.camera.positionZ);

                renderer = new THREE.WebGLRenderer({ 
                    alpha: true,
                    antialias: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvasContainer').appendChild(renderer.domElement);

                loadBeast();
                initRhythmRing();
                setupEventHandlers();
                animate();
            }

            function loadBeast() {
                new THREE.TextureLoader().load('beast_spritesheet.png', 
                    texture => {
                        texture.minFilter = THREE.NearestFilter;
                        texture.magFilter = THREE.NearestFilter;
                        texture.repeat.set(1/config.sprite.tilesHoriz, 1/config.sprite.tilesVert);

                        const aspect = config.sprite.frameWidth / config.sprite.frameHeight;
                        const geometry = new THREE.PlaneGeometry(
                            aspect * config.sprite.scale,
                            config.sprite.scale
                        );

                        const material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: true,
                            depthWrite: false
                        });

                        beast = new THREE.Mesh(geometry, material);
                        beast.position.set(0, 0, config.sprite.positionZ);
                        scene.add(beast);

                        animateSprite(texture);
                    },
                    undefined,
                    err => console.error('Ошибка загрузки текстуры:', err)
                );
            }

            function animateSprite(texture) {
                let currentFrame = 0;
                let lastUpdate = 0;

                function update(time) {
                    if (!isCameraReady) return;
                    
                    if (time - lastUpdate > config.sprite.frameDuration) {
                        currentFrame = (currentFrame + 1) % config.sprite.tilesHoriz;
                        texture.offset.x = currentFrame / config.sprite.tilesHoriz;
                        lastUpdate = time;
                    }
                    requestAnimationFrame(update);
                }
                update(0);
            }

            function initRhythmRing() {
                const geometry = new THREE.RingGeometry(
                    config.rhythm.radius - 0.15,
                    config.rhythm.radius,
                    32
                );
                
                const material = new THREE.MeshBasicMaterial({
                    color: 0xFFA500,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });

                pulseRing = new THREE.Mesh(geometry, material);
                pulseRing.position.set(0, 0, config.sprite.positionZ + 0.05);
                scene.add(pulseRing);
            }

            function setupEventHandlers() {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                let downTime = 0;

                function handleTapStart(e) {
                    downTime = Date.now();
                }

                function handleTapEnd(e) {
                    if (Date.now() - downTime > 200) return;
                    if (!isCameraReady) return;

                    const rect = renderer.domElement.getBoundingClientRect();
                    const clientX = e.clientX || e.touches[0].clientX;
                    const clientY = e.clientY || e.touches[0].clientY;

                    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    
                    // Проверка пересечения со зверем
                    const beastIntersects = raycaster.intersectObject(beast);
                    if (beastIntersects.length > 0) {
                        handleCatch();
                        return;
                    }

                    // Проверка пересечения с кольцом
                    const ringIntersects = raycaster.intersectObject(pulseRing);
                    if (ringIntersects.length > 0) {
                        handleRingTap();
                    }
                }

                function handleCatch() {
                    triggerVibration(50);
                    beast.scale.set(1.3, 1.3, 1);
                    setTimeout(() => beast.scale.set(1, 1, 1), 200);
                }

                function handleRingTap() {
                    triggerVibration(30);
                    pulseRing.scale.set(1.1, 1.1, 1);
                    setTimeout(() => pulseRing.scale.set(1, 1, 1), 200);
                }

                function triggerVibration(duration) {
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp.HapticFeedback) {
                        Telegram.WebApp.HapticFeedback.impactOccurred('medium');
                    } else if (navigator.vibrate) {
                        navigator.vibrate(duration);
                    }
                }

                window.addEventListener('mousedown', handleTapStart);
                window.addEventListener('touchstart', handleTapStart);
                window.addEventListener('mouseup', handleTapEnd);
                window.addEventListener('touchend', handleTapEnd);
            }

            function animate() {
                requestAnimationFrame(animate);
                if (!isCameraReady) return;

                // Плавная пульсация кольца
                const time = Date.now() * 0.001;
                const scale = 1 + Math.sin(time * 3) * config.rhythm.pulseSpeed;
                pulseRing.scale.set(
                    Math.min(scale, config.rhythm.maxScale),
                    Math.min(scale, config.rhythm.maxScale),
                    1
                );

                renderer.render(scene, camera);
            }

            window.addEventListener('load', initCamera);
            window.addEventListener('resize', () => {
                if (!camera) return;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        })();
    </script>
</body>
</html>